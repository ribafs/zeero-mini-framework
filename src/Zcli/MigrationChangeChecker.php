<?php

namespace Zeero\Zcli;

use Zeero\DataBase\QueryBuilder\SchemaBuilder\Alter;
use Zeero\Database\QueryBuilder\SchemaBuilder\Schema;
use Zeero\Database\QueryBuilder\SchemaBuilder\Table;
use Zeero\Database\SchemaInfo;

/**
 * 
 * Migration Changes Controller
 * 
 * @author carlos bumba <carlosbumbanio@gmail.com>
 */
class MigrationChangeChecker
{
    /**
     * current table name
     *
     * @var string
     */
    private string $table;
    /**
     * the list of columns
     *
     * @var array
     */
    private array $columns;
    /**
     * the list of foreign keys
     *
     * @var array
     */
    private array $fks;
    /**
     * the list of columns names
     *
     * @var array
     */
    private array $names;
    /**
     * the list of unique indexes
     *
     * @var array
     */
    private array $uniques;

    /**
     * statments list
     *
     * @var array
     */
    private array $statments;

    /**
     * SchemaBuilder
     *
     * @var Schema
     */
    private Schema $builder;

    // columns
    private int $deleted_columns = 0;
    private int $new_columns = 0;
    private int $modified = 0;
    // constraints
    private int $deleted_fks = 0;
    private int $new_fks = 0;
    private int $modified_fks = 0;
    // alter sql
    private string $alter;

    /**
     * @param string $table the current table
     * @param array $columns the current table parsed columns
     * @param array $fks the current table parsed foreign keys
     * @param array $names the columns names
     * @param array $uniques the unique keys
     */
    public function __construct(string $table, array $columns, array $fks, array $names, array $uniques)
    {
        $this->table = $table;
        $this->columns = $columns;
        $this->fks = $fks;
        $this->names = $names;
        $this->uniques = $uniques;
    }


    /**
     * columns state
     *
     * @return array
     */
    public function getColumnsStates()
    {
        return [$this->new_columns, $this->deleted_columns, $this->modified];
    }

    /**
     * constraints state
     *
     * @return array
     */
    public function getConstraintsStates()
    {
        return [$this->new_fks, $this->deleted_fks, $this->modified_fks];
    }


    /**
     * get the alter sql generated by *verify() method
     *
     * @return string|null
     */
    public function getAlterSQL()
    {
        return $this->alter;
    }


    /**
     * verify missing columns
     *
     * @param array $list
     * @return string
     */
    private function verifyDeletedColumns(array $list)
    {
        $sql = $this->builder->alter($this->table, function (Alter $tbl) use ($list) {
            foreach ($list as $item) {
                $this->deleted_columns += 1;
                $tbl->dropColumn($item);
            }
        });

        return $sql;
    }


    /**
     * verify new columns
     *
     * @param array $list
     * @return string
     */
    private function verifyNewColumns(array $list)
    {
        // filtered statment list
        $statments_list = [];

        foreach ($list as $item) {
            $index = array_search($item, $this->names);
            $statments_list[] = substr($this->statments[$index], 0, -1);
        }

        $sql = $this->builder->alter($this->table, function (Alter $alt) use ($statments_list) {
            $alt->add(function (Table $tbl) use ($statments_list) {
                foreach ($statments_list as $item) {
                    $this->new_columns += 1;
                    eval("\$tbl->$item;");
                }
            });
        });

        return $sql;
    }


    /**
     * verify deleted foreign keys
     *
     * @param array $list
     * @return string
     */
    private function verifyDeletedFks(array $list)
    {
        $sql = $this->builder->alter($this->table, function (Alter $alt) use ($list) {
            foreach ($list as $item) {
                $this->deleted_fks += 1;
                $alt->dropConstraint($item);
            }
        });

        return $sql;
    }



    /**
     * verify new foreign keys
     *
     * @param array $list
     * @return string
     */
    public function verifyNewFks(array $list, array $names)
    {
        $sql = '';

        foreach ($list as $item) {
            $this->new_fks += 1;
            $info = $this->fks[array_search($item, $names)];
            $sql .= "ALTER TABLE {$this->table} ADD CONSTRAINT `{$item}` ";
            $sql .= "FOREIGN KEY (`{$info['foreign_col']}`) REFERENCES {$info['ref_table']} (`{$info['ref_col']}`) ";
            $sql .= "ON DELETE {$info['delete_rule']} ON UPDATE {$info['update_rule']};";
        }

        return $sql;
    }


    /**
     * test if has only KEY difference
     *
     * @param array|null $diff
     * @param string $key
     * @return boolean
     */
    private function hasOnlyDiffColKey($diff, string $key = 'COLUMN_KEY')
    {
        if (isset($diff) and count($diff) == 1) {
            if (array_keys($diff)[0] == $key) return true;
        }

        return false;
    }


    /**
     * extract foreign keys names from parsed array
     *
     * @param array $list
     * @return array
     */
    private function getFkNames(array $list)
    {
        $names = [];

        foreach ($list as $item) {
            $names[] = $item['fk'];
        }

        return $names;
    }



    /**
     * try fix Default 'NULL' bug
     *
     * @param array|null $diff
     * @param array $info
     * @return void
     */
    private function TryFixDefault($diff, array &$info)
    {
        if (isset($diff)) {
            $bool = $this->hasOnlyDiffColKey($diff, 'COLUMN_DEFAULT');
            if ($bool and $info['IS_NULLABLE'] == 'YES') {
                $info['COLUMN_DEFAULT'] = 'NULL';
            }
        }
    }


    /**
     * compare columns details
     *
     * @param array $db_columns
     * @return string
     */
    private function compareColumnsEntries(array $db_columns)
    {
        // statements to modification
        // index to delete
        // index to insert
        $statments_list = [];
        $indexDelete = [];
        $indexInsert = [];

        $names = $this->names;

        for ($i = 0; $i < count($db_columns); $i++) {
            $from_db = $db_columns[$i];

            if (!in_array($from_db['COLUMN_NAME'], $names)) {
                continue;
            } else {
                $index = array_search($from_db['COLUMN_NAME'], $names);
                $from_migration = $this->columns[$index];
            }

            $diff_db = $diff_mg = null;

            if ($from_db < $from_migration) {
                // from migration
                $diff_mg = array_diff_assoc($from_migration, $from_db);

                if (array_key_exists('COLUMN_KEY', $diff_mg)) {
                    $target = $diff_mg['COLUMN_KEY'];

                    if ($target == 'UNI') {
                        $indexInsert[] = ['unique', $from_migration['COLUMN_NAME'],  $this->uniques[$from_migration['COLUMN_NAME']]];
                    } else {
                        $indexInsert[] = ['primary', $from_migration['COLUMN_NAME']];
                    }
                }
            }

            if ($from_db > $from_migration) {
                // avoid SqlToArray predefined value
                if ($from_migration['COLUMN_KEY'] == 'MUL' and $from_migration['EXTRA'] == 'auto_increment')
                    $from_migration['COLUMN_KEY'] = 'PRI';

                // from database
                $diff_db = array_diff($from_db, $from_migration);

                $indexName = SchemaInfo::getColumnIndexName($this->table, $from_db['COLUMN_NAME']);

                if (array_key_exists('COLUMN_KEY', $diff_db)) {
                    $target = $diff_db['COLUMN_KEY'];
                    if ($target == 'UNI') $indexDelete[] = [1, $indexName];
                    if ($target == 'PRI') $indexDelete[] = [2];
                }
            }


            $this->TryFixDefault($diff_db, $from_migration);
            $this->TryFixDefault($diff_mg, $from_db);

            if ($from_db != $from_migration) {

                $bool = false;

                $bool = $this->hasOnlyDiffColKey($diff_db);

                if (!$bool) $bool = $this->hasOnlyDiffColKey($diff_mg);

                if (!$bool) {
                    if (!$this->hasOnlyDiffColKey($diff_db, 'EXTRA') and !$this->hasOnlyDiffColKey($diff_mg, 'EXTRA'))
                        $statments_list[] = $this->statments[$i];
                }
            }
        }


        $sql = $this->builder->alter($this->table, function (Alter $alt)
        use ($statments_list, $indexDelete, $indexInsert) {

            // modify
            $alt->modify(function (Table $tbl) use ($statments_list) {
                foreach ($statments_list as $item) {
                    $this->modified += 1;
                    eval("\$tbl->$item;");
                }
            });

            // drop
            foreach ($indexDelete as $info) {
                $this->modified += 1;
                if (count($info) == 1) {
                    $alt->dropPrimary();
                } else {
                    $alt->dropIndex($info[1]);
                }
            }

            // add
            foreach ($indexInsert as $info) {
                $this->modified += 1;
                $alt->addIndex($info[0], $info[1], $info[2] ?? '');
            }
        });

        return $sql;
    }



    /**
     * compare constraints details
     *
     * @param array $db_fks
     * @param array $names
     * @param array $new
     * @return string
     */
    private function compareConstraintEntries(array $db_fks, array $names, array $new)
    {
        $drop = $add = '';

        for ($i = 0; $i < count($db_fks); $i++) {
            $from_db = $db_fks[$i];
            $index = array_search($from_db['fk'], $names);
            $from_migration = $this->fks[$index];

            // swap
            if ($from_db < $from_migration) {
                $tmp = $from_db;
                $from_db = $from_migration;
                $from_migration = $tmp;
            }

            // ignore new constraints
            if (in_array($from_db['fk'], $new)) {
                continue;
            }

            // drop and add string
            if ($from_db > $from_migration) {
                // from migration : update
                // in this case the old must be removed
                $drop .= $this->verifyDeletedFks([$from_db['fk']]);
                // add constraint string
                $add .= $this->verifyNewFks([$from_db['fk']], $names);
                $this->modified_fks += 1;
            }
        }

        return $drop . $add;
    }


    /**
     * compare columns
     *
     * @param array $db_columns
     * @param array $db_columns_names
     * @return string
     */
    private function compareColumnState(array $db_columns, array $db_columns_names)
    {
        // deleted in migration but present in database
        $deleted_columns = array_diff($db_columns_names, $this->names);
        // new columns
        $new_columns = array_diff($this->names, $db_columns_names);

        $sql = '';

        if (count($deleted_columns)) {
            $sql .= $this->verifyDeletedColumns($deleted_columns);
        }

        if (count($new_columns)) {
            $sql .= $this->verifyNewColumns($new_columns);
        }

        $sql .= $this->compareColumnsEntries($db_columns);

        return $sql;
    }



    /**
     * compare foreign keys
     *
     * @param array $db_fks
     * @return string
     */
    private function compareForeignKeyState(array $db_fks)
    {
        // migration fks
        $fks = $this->fks;
        $fks_names = $this->getFkNames($fks);
        // database
        $db_fks_names = $this->getFkNames($db_fks);

        // deleted
        $deleted = array_diff($db_fks_names, $fks_names);
        // new
        $new = array_diff($fks_names, $db_fks_names);

        $sql = '';

        $sql .= $this->compareConstraintEntries($db_fks, $fks_names, $new);

        if (count($deleted)) {
            $sql .= $this->verifyDeletedFks($deleted);
        }

        if (count($new)) {
            $sql .= $this->verifyNewFks($new, $fks_names);
        }

        return $sql;
    }


    /**
     * verify and execute changes in migration
     *
     * @return bool
     */
    public function verify()
    {
        // from database
        $db_columns = SchemaInfo::getColumns($this->table);
        $db_fks = SchemaInfo::getTableForeignKeyConstraint($this->table);
        // database columns names
        $db_columns_names = [];

        foreach ($db_columns as $value) {
            $db_columns_names[] = $value['COLUMN_NAME'];
        }
        // 
        $this->statments = ColumnTransform::getStatments($this->columns, $this->fks);

        // instatiate Schema
        $this->builder = new Schema;

        $sql =  $this->compareColumnState($db_columns, $db_columns_names);
        $sql .= $this->compareForeignKeyState($db_fks);

        $this->alter = $sql;

        return strlen($sql) > 0;
    }
}
